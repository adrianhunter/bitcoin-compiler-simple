// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as Caml_obj from "../node_modules/rescript/lib/es6/caml_obj.js";
import * as Caml_int32 from "../node_modules/rescript/lib/es6/caml_int32.js";
import * as Pervasives from "../node_modules/rescript/lib/es6/pervasives.js";
import * as Caml_option from "../node_modules/rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "../node_modules/rescript/lib/es6/caml_exceptions.js";

function fooo(a, b) {
  return {};
}

function add(stack, a, b) {
  return stack;
}

function add1(a) {
  return {};
}

function sub1(stack) {
  return stack;
}

function size(stack) {
  return 1;
}

function hash160(stack) {
  return stack;
}

function dup(stack) {
  return stack;
}

function verify(stack) {
  return stack;
}

function checksig(sig, pubkey) {
  return true;
}

function sha256(stack) {
  return {};
}

function num2bin($$int, b) {
  return $$int;
}

function bin2num(bytes) {
  return bytes;
}

function int_of_string(string) {
  return string;
}

function string_of_bytes(bytes) {
  return bytes;
}

function bytes_of_string(bytes) {
  return bytes;
}

function cat(bytes, bytes$1) {
  return {};
}

function split(stack, post) {
  return stack;
}

function drop(stack) {
  return stack;
}

function invert(stack) {
  return stack;
}

function equal(a, b) {
  return {};
}

function swap(stack) {
  return stack;
}

var NotEqualverify = /* @__PURE__ */Caml_exceptions.create("Script.NotEqualverify");

function equalverify(stack, value) {
  return stack;
}

function $eq$eq(a, b) {
  return a === b;
}

var $eq = Caml_obj.caml_equal;

function $amp$amp(a, b) {
  if (a) {
    return b;
  } else {
    return false;
  }
}

function $pipe$pipe(a, b) {
  if (a) {
    return true;
  } else {
    return b;
  }
}

function $plus(a, b) {
  return a + b | 0;
}

function $caret(a, b) {
  return a + b;
}

function $neg(a, b) {
  return a - b | 0;
}

var $slash = Caml_int32.div;

function $star(a, b) {
  return Math.imul(a, b);
}

var $great = Caml_obj.caml_greaterthan;

var $great$eq = Caml_obj.caml_greaterequal;

var $less = Caml_obj.caml_lessthan;

var $less$eq = Caml_obj.caml_lessequal;

function foo(a) {
  return {};
}

function $eq$unknown$lbrack$rbrack(a) {
  return [a];
}

function loop(fn, times) {
  return Curry._1(fn, 1);
}

function slice(bytes, start, end_) {
  return bytes;
}

function sliceString(string, start, end_) {
  return string;
}

function $pipe$bang(o, d) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return Pervasives.failwith(d);
  }
}

function $pipe$question$great$great(o, fn) {
  if (o !== undefined) {
    return Caml_option.some(Curry._1(fn, Caml_option.valFromOption(o)));
  }
  
}

function $pipe$question$great(o, fn) {
  if (o !== undefined) {
    return Curry._1(fn, Caml_option.valFromOption(o));
  }
  
}

function length(string) {
  return {};
}

function slice$1(string, start, end_) {
  return string;
}

function string_of_int(a, $$int) {
  return a;
}

var $$String = {
  length: length,
  slice: slice$1,
  string_of_int: string_of_int
};

export {
  fooo ,
  add ,
  add1 ,
  sub1 ,
  size ,
  hash160 ,
  dup ,
  verify ,
  checksig ,
  sha256 ,
  num2bin ,
  bin2num ,
  int_of_string ,
  string_of_bytes ,
  bytes_of_string ,
  cat ,
  split ,
  drop ,
  invert ,
  equal ,
  swap ,
  NotEqualverify ,
  equalverify ,
  $eq$eq ,
  $eq ,
  $amp$amp ,
  $pipe$pipe ,
  $plus ,
  $caret ,
  $neg ,
  $slash ,
  $star ,
  $great ,
  $great$eq ,
  $less ,
  $less$eq ,
  foo ,
  $eq$unknown$lbrack$rbrack ,
  loop ,
  slice ,
  sliceString ,
  $pipe$bang ,
  $pipe$question$great$great ,
  $pipe$question$great ,
  $$String ,
  
}
/* No side effect */
